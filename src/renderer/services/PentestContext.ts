// PentestContext - Global state for pentest intelligence
// Stores discovered information and generates dynamic recommendations

export interface DiscoveredPort {
  port: number;
  protocol: 'tcp' | 'udp';
  state: 'open' | 'filtered' | 'closed';
  service: string;
  version?: string;
  product?: string;
  extraInfo?: string;
}

export interface DiscoveredHost {
  ip: string;
  hostname?: string;
  os?: string;
  ports: DiscoveredPort[];
  lastScan?: Date;
}

export interface DiscoveredPath {
  url: string;
  status: number;
  size?: number;
  type?: string; // directory, file, redirect
}

export interface DiscoveredVuln {
  id: string;
  name: string;
  severity: 'critical' | 'high' | 'medium' | 'low' | 'info';
  service?: string;
  port?: number;
  description?: string;
  exploit?: string;
  cve?: string;
}

export interface DiscoveredCredential {
  username: string;
  password?: string;
  hash?: string;
  service?: string;
  source: string;
}

export interface GeneratedCommand {
  id: string;
  command: string;
  description: string;
  category: string;
  phase: string;
  priority: number; // 1-10, higher = more important
  tags: string[];
  requiresContext?: string[]; // what context is needed
}

export interface AttackPhase {
  id: string;
  name: string;
  description: string;
  status: 'locked' | 'available' | 'in_progress' | 'completed';
  commands: GeneratedCommand[];
  unlockConditions: string[]; // what needs to be discovered to unlock
}

class PentestContextClass {
  private hosts: Map<string, DiscoveredHost> = new Map();
  private paths: Map<string, DiscoveredPath[]> = new Map(); // key = base URL
  private vulns: DiscoveredVuln[] = [];
  private credentials: DiscoveredCredential[] = [];
  private currentTarget: string | null = null;
  private commandHistory: { command: string; output: string; timestamp: Date }[] = [];
  private lastDetectedTool: string = '';
  private listeners: Set<() => void> = new Set();

  // Subscribe to context changes
  subscribe(callback: () => void): () => void {
    this.listeners.add(callback);
    return () => this.listeners.delete(callback);
  }

  private notify(): void {
    this.listeners.forEach(cb => cb());
  }

  // Set current target
  setCurrentTarget(ip: string): void {
    this.currentTarget = ip;
    if (!this.hosts.has(ip)) {
      this.hosts.set(ip, { ip, ports: [] });
    }
    this.notify();
  }

  getCurrentTarget(): string | null {
    return this.currentTarget;
  }

  getLastDetectedTool(): string {
    return this.lastDetectedTool;
  }

  // Parse and analyze terminal output
  analyzeOutput(output: string): void {
    // Detect which tool produced this output
    if (output.includes('Nmap scan report') || output.includes('PORT') && output.includes('STATE')) {
      this.lastDetectedTool = 'nmap';
      this.parseNmapOutput(output);
    } else if (output.includes('rustscan') || output.match(/Open.*\d+\.\d+\.\d+\.\d+:\d+/i)) {
      this.lastDetectedTool = 'rustscan';
      this.parseRustscanOutput(output);
    } else if (output.includes('gobuster') || output.match(/Status: \d{3}/)) {
      this.lastDetectedTool = 'gobuster';
      this.parseGobusterOutput(output);
    } else if (output.includes('ffuf') || output.includes(':: Progress')) {
      this.lastDetectedTool = 'ffuf';
      this.parseFfufOutput(output);
    } else if (output.includes('nikto') || output.includes('+ Server:')) {
      this.lastDetectedTool = 'nikto';
      this.parseNiktoOutput(output);
    } else if (output.includes('searchsploit') || output.includes('Exploit Title')) {
      this.lastDetectedTool = 'searchsploit';
    } else if (output.includes('hydra') || output.includes('login:') && output.includes('password:')) {
      this.lastDetectedTool = 'hydra';
      this.parseHydraOutput(output);
    } else if (output.includes('sqlmap') || output.includes('injection')) {
      this.lastDetectedTool = 'sqlmap';
      this.parseSqlmapOutput(output);
    }

    this.notify();
  }

  private parseNmapOutput(output: string): void {
    // Extract target IP
    const ipMatch = output.match(/Nmap scan report for (?:(\S+) \()?(\d+\.\d+\.\d+\.\d+)\)?/);
    if (ipMatch) {
      const ip = ipMatch[2];
      const hostname = ipMatch[1];

      if (!this.hosts.has(ip)) {
        this.hosts.set(ip, { ip, hostname, ports: [] });
      }

      const host = this.hosts.get(ip)!;
      if (hostname) host.hostname = hostname;

      // Extract ports - pattern: PORT/PROTOCOL STATE SERVICE VERSION
      const portRegex = /(\d+)\/(tcp|udp)\s+(open|filtered|closed)\s+(\S+)(?:\s+(.+))?/g;
      let match;
      while ((match = portRegex.exec(output)) !== null) {
        const [, portStr, protocol, state, service, versionInfo] = match;
        const port = parseInt(portStr);

        // Parse version info
        let version = '';
        let product = '';
        if (versionInfo) {
          // Try to extract version like "Apache httpd 2.4.41" or "OpenSSH 8.2p1"
          const versionMatch = versionInfo.match(/(\S+)(?:\s+(\S+))?(?:\s+([\d.]+\S*))?/);
          if (versionMatch) {
            product = versionMatch[1] || '';
            version = versionMatch[3] || versionMatch[2] || '';
          }
        }

        const existingPort = host.ports.find(p => p.port === port && p.protocol === protocol);
        if (existingPort) {
          existingPort.state = state as 'open' | 'filtered' | 'closed';
          existingPort.service = service;
          if (version) existingPort.version = version;
          if (product) existingPort.product = product;
          existingPort.extraInfo = versionInfo;
        } else {
          host.ports.push({
            port,
            protocol: protocol as 'tcp' | 'udp',
            state: state as 'open' | 'filtered' | 'closed',
            service,
            version,
            product,
            extraInfo: versionInfo,
          });
        }
      }

      // Extract OS info
      const osMatch = output.match(/OS details?:\s*(.+)/i);
      if (osMatch) {
        host.os = osMatch[1];
      }

      host.lastScan = new Date();
      this.currentTarget = ip;
    }
  }

  private parseRustscanOutput(output: string): void {
    // Extract IP and ports from rustscan
    const ipMatch = output.match(/(\d+\.\d+\.\d+\.\d+)/);
    const portsMatch = output.match(/Open (\d+\.\d+\.\d+\.\d+):(\d+)/g);

    if (ipMatch) {
      const ip = ipMatch[1];
      if (!this.hosts.has(ip)) {
        this.hosts.set(ip, { ip, ports: [] });
      }

      const host = this.hosts.get(ip)!;

      if (portsMatch) {
        portsMatch.forEach(match => {
          const portMatch = match.match(/:(\d+)/);
          if (portMatch) {
            const port = parseInt(portMatch[1]);
            if (!host.ports.find(p => p.port === port)) {
              host.ports.push({
                port,
                protocol: 'tcp',
                state: 'open',
                service: 'unknown',
              });
            }
          }
        });
      }

      this.currentTarget = ip;
    }
  }

  private parseGobusterOutput(output: string): void {
    // Extract discovered paths
    const pathRegex = /\/\S+\s+\(Status:\s*(\d+)\)/g;
    const urlMatch = output.match(/http[s]?:\/\/[^\s/]+/);
    const baseUrl = urlMatch ? urlMatch[0] : this.currentTarget ? `http://${this.currentTarget}` : '';

    if (!baseUrl) return;

    if (!this.paths.has(baseUrl)) {
      this.paths.set(baseUrl, []);
    }

    const paths = this.paths.get(baseUrl)!;
    let match;

    while ((match = pathRegex.exec(output)) !== null) {
      const pathMatch = output.substring(match.index).match(/^(\/\S+)/);
      if (pathMatch) {
        const url = `${baseUrl}${pathMatch[1]}`;
        const status = parseInt(match[1]);

        if (!paths.find(p => p.url === url)) {
          paths.push({ url, status });
        }
      }
    }
  }

  private parseFfufOutput(output: string): void {
    // Similar to gobuster
    const urlMatch = output.match(/http[s]?:\/\/[^\s/]+/);
    const baseUrl = urlMatch ? urlMatch[0] : this.currentTarget ? `http://${this.currentTarget}` : '';

    if (!baseUrl) return;

    if (!this.paths.has(baseUrl)) {
      this.paths.set(baseUrl, []);
    }

    const paths = this.paths.get(baseUrl)!;

    // FFUF output pattern: path [Status: 200, Size: 1234]
    const pathRegex = /(\S+)\s+\[Status:\s*(\d+)/g;
    let match;

    while ((match = pathRegex.exec(output)) !== null) {
      const path = match[1];
      const status = parseInt(match[2]);
      const url = path.startsWith('http') ? path : `${baseUrl}/${path}`;

      if (!paths.find(p => p.url === url)) {
        paths.push({ url, status });
      }
    }
  }

  private parseNiktoOutput(output: string): void {
    // Extract vulnerabilities from nikto
    const vulnRegex = /\+ (OSVDB-\d+|CVE-\d+-\d+)?:?\s*(.+)/g;
    let match;

    while ((match = vulnRegex.exec(output)) !== null) {
      const cve = match[1] || undefined;
      const description = match[2];

      if (description && !description.includes('Target IP:') && !description.includes('Target Hostname:')) {
        const vuln: DiscoveredVuln = {
          id: `nikto-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          name: description.substring(0, 50),
          severity: cve ? 'medium' : 'info',
          description,
          cve,
        };

        if (!this.vulns.find(v => v.description === description)) {
          this.vulns.push(vuln);
        }
      }
    }
  }

  private parseHydraOutput(output: string): void {
    // Extract credentials from hydra
    const credRegex = /\[(\d+)\]\[(\w+)\]\s+host:\s*(\S+)\s+login:\s*(\S+)\s+password:\s*(\S+)/g;
    let match;

    while ((match = credRegex.exec(output)) !== null) {
      const [, port, service, host, username, password] = match;

      if (!this.credentials.find(c => c.username === username && c.password === password && c.service === service)) {
        this.credentials.push({
          username,
          password,
          service,
          source: `hydra:${host}:${port}`,
        });
      }
    }
  }

  private parseSqlmapOutput(output: string): void {
    // Extract SQL injection info
    if (output.includes('is vulnerable')) {
      const urlMatch = output.match(/URL:\s*(\S+)/);
      const paramMatch = output.match(/Parameter:\s*(\S+)/);

      if (urlMatch) {
        const vuln: DiscoveredVuln = {
          id: `sqli-${Date.now()}`,
          name: 'SQL Injection',
          severity: 'critical',
          description: `SQL Injection found at ${urlMatch[1]}${paramMatch ? ` (param: ${paramMatch[1]})` : ''}`,
        };

        this.vulns.push(vuln);
      }
    }
  }

  // Get all discovered hosts
  getHosts(): DiscoveredHost[] {
    return Array.from(this.hosts.values());
  }

  // Get current host
  getCurrentHost(): DiscoveredHost | null {
    if (!this.currentTarget) return null;
    return this.hosts.get(this.currentTarget) || null;
  }

  // Get discovered paths for a URL
  getPaths(baseUrl?: string): DiscoveredPath[] {
    if (baseUrl) {
      return this.paths.get(baseUrl) || [];
    }
    return Array.from(this.paths.values()).flat();
  }

  // Get all vulnerabilities
  getVulns(): DiscoveredVuln[] {
    return this.vulns;
  }

  // Get credentials
  getCredentials(): DiscoveredCredential[] {
    return this.credentials;
  }

  // Generate dynamic commands based on current context
  generateCommands(): GeneratedCommand[] {
    const commands: GeneratedCommand[] = [];
    const host = this.getCurrentHost();
    const target = this.currentTarget || 'TARGET';

    // If no target yet, show initial recon commands
    if (!host || host.ports.length === 0) {
      commands.push(
        { id: 'recon-1', command: `nmap -sC -sV -oN nmap_initial.txt ${target}`, description: 'Initial service scan with scripts', category: 'Reconnaissance', phase: 'recon', priority: 10, tags: ['nmap', 'recon'] },
        { id: 'recon-2', command: `rustscan -a ${target} -- -sC -sV`, description: 'Fast port scan + nmap scripts', category: 'Reconnaissance', phase: 'recon', priority: 9, tags: ['rustscan', 'recon'] },
        { id: 'recon-3', command: `nmap -sU -top-ports 20 ${target}`, description: 'UDP top ports scan', category: 'Reconnaissance', phase: 'recon', priority: 7, tags: ['nmap', 'udp', 'recon'] },
        { id: 'recon-4', command: `nmap -p- -T4 ${target}`, description: 'Full port scan', category: 'Reconnaissance', phase: 'recon', priority: 8, tags: ['nmap', 'fullscan'] },
        { id: 'recon-5', command: `masscan -p1-65535 ${target} --rate=1000`, description: 'Masscan full port', category: 'Reconnaissance', phase: 'recon', priority: 6, tags: ['masscan'] },
      );
      return commands;
    }

    // Generate commands based on discovered services
    const openPorts = host.ports.filter(p => p.state === 'open');

    for (const port of openPorts) {
      const service = port.service.toLowerCase();
      const version = port.version || '';
      const product = port.product || '';
      const fullVersion = `${product} ${version}`.trim();

      // HTTP/HTTPS services (80, 443, 8080, etc.)
      if (service.includes('http') || port.port === 80 || port.port === 443 || port.port === 8080 || port.port === 8443) {
        const proto = port.port === 443 || port.port === 8443 ? 'https' : 'http';
        const url = `${proto}://${target}:${port.port}`;

        commands.push(
          { id: `web-dir-${port.port}`, command: `gobuster dir -u ${url} -w /usr/share/wordlists/dirb/common.txt -t 50`, description: `Directory bruteforce on port ${port.port}`, category: 'Web Enumeration', phase: 'enum', priority: 9, tags: ['gobuster', 'web'] },
          { id: `web-ffuf-${port.port}`, command: `ffuf -u ${url}/FUZZ -w /usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt -mc 200,301,302,403`, description: `Fuzz directories on port ${port.port}`, category: 'Web Enumeration', phase: 'enum', priority: 8, tags: ['ffuf', 'web'] },
          { id: `web-nikto-${port.port}`, command: `nikto -h ${url}`, description: `Vulnerability scan on port ${port.port}`, category: 'Vulnerability Scan', phase: 'vuln', priority: 8, tags: ['nikto', 'vuln'] },
          { id: `web-whatweb-${port.port}`, command: `whatweb -a 3 ${url}`, description: `Technology detection on port ${port.port}`, category: 'Web Enumeration', phase: 'enum', priority: 7, tags: ['whatweb', 'web'] },
          { id: `web-nuclei-${port.port}`, command: `nuclei -u ${url} -t cves/ -t vulnerabilities/`, description: `CVE scan on port ${port.port}`, category: 'Vulnerability Scan', phase: 'vuln', priority: 9, tags: ['nuclei', 'cve'] },
          { id: `web-wpscan-${port.port}`, command: `wpscan --url ${url} --enumerate ap,at,u`, description: `WordPress scan (if applicable)`, category: 'CMS Scan', phase: 'enum', priority: 6, tags: ['wpscan', 'wordpress'] },
          { id: `web-curl-${port.port}`, command: `curl -v ${url}`, description: `Manual inspection`, category: 'Manual Testing', phase: 'enum', priority: 5, tags: ['curl', 'manual'] },
        );

        // If we found paths, add path-specific commands
        const discoveredPaths = this.getPaths(url);
        for (const path of discoveredPaths.slice(0, 5)) {
          if (path.status === 200 || path.status === 301 || path.status === 302) {
            commands.push(
              { id: `path-${path.url}`, command: `curl -v "${path.url}"`, description: `Inspect ${path.url}`, category: 'Path Analysis', phase: 'enum', priority: 7, tags: ['curl', 'path'] },
            );
          }
        }

        // Version-specific exploits
        if (fullVersion) {
          commands.push(
            { id: `searchsploit-${port.port}`, command: `searchsploit "${fullVersion}"`, description: `Search exploits for ${fullVersion}`, category: 'Exploit Research', phase: 'exploit', priority: 9, tags: ['searchsploit', 'exploit'] },
          );

          // PHP specific
          if (fullVersion.toLowerCase().includes('php')) {
            commands.push(
              { id: `php-exploit-${port.port}`, command: `searchsploit "php ${version}"`, description: `PHP ${version} exploits`, category: 'Exploit Research', phase: 'exploit', priority: 9, tags: ['php', 'exploit'] },
            );
          }

          // Apache specific
          if (fullVersion.toLowerCase().includes('apache')) {
            commands.push(
              { id: `apache-exploit-${port.port}`, command: `searchsploit "apache ${version}"`, description: `Apache ${version} exploits`, category: 'Exploit Research', phase: 'exploit', priority: 9, tags: ['apache', 'exploit'] },
            );
          }
        }
      }

      // SSH (22)
      if (service.includes('ssh') || port.port === 22) {
        commands.push(
          { id: `ssh-enum-${port.port}`, command: `nmap -p ${port.port} --script ssh-auth-methods,ssh-hostkey ${target}`, description: 'SSH enumeration scripts', category: 'SSH Enumeration', phase: 'enum', priority: 8, tags: ['nmap', 'ssh'] },
          { id: `ssh-brute-${port.port}`, command: `hydra -L /usr/share/wordlists/metasploit/unix_users.txt -P /usr/share/wordlists/rockyou.txt ssh://${target}:${port.port} -t 4`, description: 'SSH brute force', category: 'Brute Force', phase: 'exploit', priority: 6, tags: ['hydra', 'ssh', 'brute'] },
        );

        if (version) {
          commands.push(
            { id: `ssh-exploit-${port.port}`, command: `searchsploit "openssh ${version}"`, description: `OpenSSH ${version} exploits`, category: 'Exploit Research', phase: 'exploit', priority: 8, tags: ['searchsploit', 'ssh'] },
          );
        }
      }

      // FTP (21)
      if (service.includes('ftp') || port.port === 21) {
        commands.push(
          { id: `ftp-anon-${port.port}`, command: `nmap -p ${port.port} --script ftp-anon,ftp-bounce,ftp-syst,ftp-vsftpd-backdoor ${target}`, description: 'FTP enumeration + backdoor check', category: 'FTP Enumeration', phase: 'enum', priority: 9, tags: ['nmap', 'ftp'] },
          { id: `ftp-brute-${port.port}`, command: `hydra -L /usr/share/wordlists/metasploit/unix_users.txt -P /usr/share/wordlists/rockyou.txt ftp://${target}:${port.port}`, description: 'FTP brute force', category: 'Brute Force', phase: 'exploit', priority: 7, tags: ['hydra', 'ftp', 'brute'] },
          { id: `ftp-connect-${port.port}`, command: `ftp ${target} ${port.port}`, description: 'Connect to FTP (try anonymous)', category: 'Manual Testing', phase: 'enum', priority: 8, tags: ['ftp', 'manual'] },
        );
      }

      // SMB (445, 139)
      if (service.includes('smb') || service.includes('microsoft-ds') || service.includes('netbios') || port.port === 445 || port.port === 139) {
        commands.push(
          { id: `smb-enum-${port.port}`, command: `nmap -p 445 --script smb-enum-shares,smb-enum-users,smb-os-discovery ${target}`, description: 'SMB enumeration', category: 'SMB Enumeration', phase: 'enum', priority: 9, tags: ['nmap', 'smb'] },
          { id: `smb-vuln-${port.port}`, command: `nmap -p 445 --script smb-vuln* ${target}`, description: 'SMB vulnerability scan (EternalBlue, etc.)', category: 'Vulnerability Scan', phase: 'vuln', priority: 10, tags: ['nmap', 'smb', 'vuln'] },
          { id: `smb-smbclient-${port.port}`, command: `smbclient -L //${target}/ -N`, description: 'List SMB shares (no password)', category: 'SMB Enumeration', phase: 'enum', priority: 8, tags: ['smbclient', 'smb'] },
          { id: `smb-enum4-${port.port}`, command: `enum4linux -a ${target}`, description: 'Full SMB/NetBIOS enumeration', category: 'SMB Enumeration', phase: 'enum', priority: 9, tags: ['enum4linux', 'smb'] },
          { id: `smb-crackmapexec-${port.port}`, command: `crackmapexec smb ${target}`, description: 'CrackMapExec SMB info', category: 'SMB Enumeration', phase: 'enum', priority: 8, tags: ['crackmapexec', 'smb'] },
        );
      }

      // MySQL (3306)
      if (service.includes('mysql') || port.port === 3306) {
        commands.push(
          { id: `mysql-enum-${port.port}`, command: `nmap -p ${port.port} --script mysql-info,mysql-enum,mysql-empty-password ${target}`, description: 'MySQL enumeration', category: 'Database Enumeration', phase: 'enum', priority: 9, tags: ['nmap', 'mysql'] },
          { id: `mysql-brute-${port.port}`, command: `hydra -L /usr/share/wordlists/metasploit/unix_users.txt -P /usr/share/wordlists/rockyou.txt mysql://${target}:${port.port}`, description: 'MySQL brute force', category: 'Brute Force', phase: 'exploit', priority: 7, tags: ['hydra', 'mysql', 'brute'] },
        );
      }

      // PostgreSQL (5432)
      if (service.includes('postgres') || port.port === 5432) {
        commands.push(
          { id: `postgres-enum-${port.port}`, command: `nmap -p ${port.port} --script pgsql-brute ${target}`, description: 'PostgreSQL brute', category: 'Database Enumeration', phase: 'enum', priority: 8, tags: ['nmap', 'postgres'] },
        );
      }

      // RDP (3389)
      if (service.includes('rdp') || service.includes('ms-wbt') || port.port === 3389) {
        commands.push(
          { id: `rdp-enum-${port.port}`, command: `nmap -p ${port.port} --script rdp-ntlm-info,rdp-enum-encryption ${target}`, description: 'RDP enumeration', category: 'RDP Enumeration', phase: 'enum', priority: 8, tags: ['nmap', 'rdp'] },
          { id: `rdp-brute-${port.port}`, command: `hydra -L users.txt -P /usr/share/wordlists/rockyou.txt rdp://${target}:${port.port}`, description: 'RDP brute force', category: 'Brute Force', phase: 'exploit', priority: 6, tags: ['hydra', 'rdp', 'brute'] },
        );
      }

      // LDAP (389, 636)
      if (service.includes('ldap') || port.port === 389 || port.port === 636) {
        commands.push(
          { id: `ldap-enum-${port.port}`, command: `ldapsearch -x -H ldap://${target}:${port.port} -b "dc=domain,dc=local"`, description: 'LDAP enumeration', category: 'LDAP Enumeration', phase: 'enum', priority: 8, tags: ['ldapsearch', 'ldap'] },
          { id: `ldap-nmap-${port.port}`, command: `nmap -p ${port.port} --script ldap-search,ldap-rootdse ${target}`, description: 'LDAP nmap scripts', category: 'LDAP Enumeration', phase: 'enum', priority: 8, tags: ['nmap', 'ldap'] },
        );
      }

      // Kerberos (88)
      if (service.includes('kerberos') || port.port === 88) {
        commands.push(
          { id: `kerb-enum-${port.port}`, command: `kerbrute userenum -d DOMAIN.LOCAL --dc ${target} /usr/share/wordlists/metasploit/unix_users.txt`, description: 'Kerberos user enumeration', category: 'AD Enumeration', phase: 'enum', priority: 9, tags: ['kerbrute', 'kerberos', 'ad'] },
          { id: `kerb-asrep-${port.port}`, command: `impacket-GetNPUsers DOMAIN.LOCAL/ -dc-ip ${target} -usersfile users.txt -no-pass`, description: 'AS-REP Roasting', category: 'AD Attack', phase: 'exploit', priority: 9, tags: ['impacket', 'asrep', 'ad'] },
        );
      }

      // DNS (53)
      if (service.includes('dns') || service.includes('domain') || port.port === 53) {
        commands.push(
          { id: `dns-enum-${port.port}`, command: `dig axfr @${target} DOMAIN.LOCAL`, description: 'DNS zone transfer attempt', category: 'DNS Enumeration', phase: 'enum', priority: 9, tags: ['dig', 'dns'] },
          { id: `dns-nmap-${port.port}`, command: `nmap -p 53 --script dns-brute ${target}`, description: 'DNS brute force', category: 'DNS Enumeration', phase: 'enum', priority: 7, tags: ['nmap', 'dns'] },
        );
      }

      // SNMP (161)
      if (service.includes('snmp') || port.port === 161) {
        commands.push(
          { id: `snmp-enum-${port.port}`, command: `snmpwalk -v2c -c public ${target}`, description: 'SNMP walk (public community)', category: 'SNMP Enumeration', phase: 'enum', priority: 8, tags: ['snmpwalk', 'snmp'] },
          { id: `snmp-nmap-${port.port}`, command: `nmap -sU -p 161 --script snmp-brute,snmp-info ${target}`, description: 'SNMP enumeration scripts', category: 'SNMP Enumeration', phase: 'enum', priority: 8, tags: ['nmap', 'snmp'] },
        );
      }

      // Redis (6379)
      if (service.includes('redis') || port.port === 6379) {
        commands.push(
          { id: `redis-cli-${port.port}`, command: `redis-cli -h ${target} -p ${port.port}`, description: 'Connect to Redis', category: 'Database Enumeration', phase: 'enum', priority: 9, tags: ['redis-cli', 'redis'] },
          { id: `redis-nmap-${port.port}`, command: `nmap -p ${port.port} --script redis-info ${target}`, description: 'Redis info', category: 'Database Enumeration', phase: 'enum', priority: 8, tags: ['nmap', 'redis'] },
        );
      }

      // MongoDB (27017)
      if (service.includes('mongo') || port.port === 27017) {
        commands.push(
          { id: `mongo-cli-${port.port}`, command: `mongosh ${target}:${port.port}`, description: 'Connect to MongoDB', category: 'Database Enumeration', phase: 'enum', priority: 9, tags: ['mongosh', 'mongodb'] },
        );
      }
    }

    // Add discovered credentials usage
    for (const cred of this.credentials) {
      if (cred.service === 'ssh') {
        commands.push(
          { id: `use-cred-ssh-${cred.username}`, command: `ssh ${cred.username}@${target}`, description: `SSH with discovered creds (${cred.username})`, category: 'Access', phase: 'exploit', priority: 10, tags: ['ssh', 'creds'] },
        );
      }
    }

    // Sort by priority
    commands.sort((a, b) => b.priority - a.priority);

    return commands;
  }

  // Get commands grouped by phase
  getCommandsByPhase(): Record<string, GeneratedCommand[]> {
    const commands = this.generateCommands();
    const grouped: Record<string, GeneratedCommand[]> = {};

    for (const cmd of commands) {
      if (!grouped[cmd.phase]) {
        grouped[cmd.phase] = [];
      }
      grouped[cmd.phase].push(cmd);
    }

    return grouped;
  }

  // Clear all data
  clear(): void {
    this.hosts.clear();
    this.paths.clear();
    this.vulns = [];
    this.credentials = [];
    this.currentTarget = null;
    this.commandHistory = [];
    this.notify();
  }

  // Export context for debugging
  exportContext(): object {
    return {
      hosts: Array.from(this.hosts.entries()),
      paths: Array.from(this.paths.entries()),
      vulns: this.vulns,
      credentials: this.credentials,
      currentTarget: this.currentTarget,
    };
  }
}

// Singleton instance
export const PentestContext = new PentestContextClass();
